"use server";

import prisma from "@/app/lib/prisma";
import {DEFAULT_PAGE_SIZE, getCollectionAndDownloadCode, getPaginationData, handleMovie,} from "./utils/commonUtils";
import {filesize} from "filesize";
import {revalidatePath} from "next/cache";
import {cookies} from 'next/headers';


const movieSelect = {

    id: true,
    tags: true,
    duration: true,
    code: true,
    rate: true,
    rateNum: true,
    releaseDate: true,
    releaseYear: true,
    actresses: {
        select: {
            id: true,
            actressName: true
        }
    },
    files: {
        where: {
            type: 2
        },
        select: {
            path: true,
            onlineUrl: true
        }
    },
}


export async function getMovieOne(movieId: number): Promise<DataResponse<Movie>> {

    try {
        const movie = await prisma.moviesInfo.findUnique({
            where: {
                id: movieId,
            },
            select: movieSelect,
        });
        if (!movie) {
            return {
                code: 500,
                msg: "Movie not found"
            };
        }
        const { ctCode, dmCode } = await getCollectionAndDownloadCode();
        const handled = handleMovie(movie, {
            ctCode,
            dmCode,
        });
        return {
            code: 200,
            data: handled as Movie,
        }


    } catch (error) {
        console.error("Error fetching movie:", error);
        return {
            code: 500,
            msg: "Error fetching movie",
        }
    }

}

export async function getMovies({
    page = 1,
    search,
    prefix,
    actressName,
    years,
    tags,
    batchId,
}: MovieQueryParams): Promise<DataResponse<Movie[]>> {
    try {
        const skip = (page - 1) * DEFAULT_PAGE_SIZE;
        const cookieStore = cookies();
        const config: GlobalSettingsConfig = JSON.parse(cookieStore.get('config')?.value || '{}');


        let relevantCodes: string[] = [];
        if (batchId) {
            const batchRecords = await prisma.crawlBatchRecord.findMany({
                where: { batchId: batchId },
                select: { code: true },
            });
            relevantCodes = batchRecords.map((record: { code: string }) => record.code);
        }

        let moviesQuery: any = {
            skip,
            take: DEFAULT_PAGE_SIZE,
            orderBy: { releaseDate: "desc" as const },
            select: movieSelect,
            where: {
                ...(search && {
                    OR: [
                        { code: { contains: search, mode: "insensitive" } },
                        {
                            actresses: {
                                some: {
                                    actressName: { contains: search, mode: "insensitive" },
                                },
                            },
                        },
                    ],
                }),
                ...(prefix && { prefix }),
                ...(actressName && {
                    actresses: {
                        some: {
                            actressName: { contains: actressName, mode: "insensitive" },
                        },
                    },
                }),
                ...(years && { releaseYear: Number(years) }),
                ...(tags && {
                    tags: {
                        some: {
                            tagName: { contains: tags, mode: "insensitive" },
                        },
                    },
                }),
                ...(batchId && {
                    code: { in: relevantCodes },
                }),
            },

        };

        const [movies, totalCount] = await Promise.all([
            prisma.moviesInfo.findMany(moviesQuery),
            prisma.moviesInfo.count({ where: moviesQuery.where }),
        ]);
        const { ctCode, dmCode } = await getCollectionAndDownloadCode();


        const handled = handleMovie(movies, {
            ctCode,
            dmCode,
        },
            config
        );
        const pagination = getPaginationData(totalCount, page, DEFAULT_PAGE_SIZE);

        return {
            data: handled as Movie[] || [],
            pagination,
            code: 200,
        };
    } catch (error) {
        console.error("Error fetching movies:", error);
        return { code: 500, msg: "Error fetching movies", data: [] };
    }
}

export async function getMoviesByActressId(
    actressId: number,
    page: number = 1,
    pageSize: number = DEFAULT_PAGE_SIZE
): Promise<DataResponse<Movie[]>> {
    try {
        const skip = (page - 1) * pageSize;
        const cookieStore = cookies();
        const config: GlobalSettingsConfig = JSON.parse(cookieStore.get('config')?.value || '{}');

        let moviesQuery = {
            skip,
            take: pageSize,
            orderBy: { releaseDate: "desc" as const },
            select: movieSelect,
            where: {
                actresses: {
                    some: {
                        id: actressId
                    }
                }
            },
        };

        const [movies, totalCount] = await Promise.all([
            prisma.moviesInfo.findMany(moviesQuery),
            prisma.moviesInfo.count({ where: moviesQuery.where }),
        ]);

        const { ctCode, dmCode } = await getCollectionAndDownloadCode();

        const handled = handleMovie(movies, {
            ctCode,
            dmCode,
        },
            config
        );

        const pagination = getPaginationData(totalCount, page, pageSize);

        return {
            data: handled as Movie[] || [],
            pagination,
            code: 200,
        };
    } catch (error) {
        console.error("Error fetching movies by actress ID:", error);
        return { code: 500, msg: "Error fetching movies by actress ID", data: [] };
    }
}

export async function getVideoResource(movieId: number): Promise<DataResponse<VideoResource[]>> {

    try {
        const movie = await prisma.moviesInfo.findUnique({
            where: { id: movieId },
            select: { code: true }
        });

        const videoResource = await prisma.moviesVideoResource.findMany({
            where: { movieCode: movie?.code },
            select: {
                path: true,
                createdTime: true,
                size: true,
                id: true
            }
        });

        const updatedResources = await Promise.all(
            videoResource.map(async (x: any) => {
                try {
                    const res = await fetch(
                        `${process.env.NEXT_PUBLIC_VIDEO_SERVER_PATH}${x.path}`,
                        {
                            method: "HEAD",
                        }
                    );
                    const size = res.headers.get("Content-Length") || 0;
                    return { ...x, size: filesize(size) };
                } catch (error) {
                    console.error("Error fetching video size:", error);
                    return x;
                }
            })
        );

        return {
            code: 200,
            data: updatedResources || []
        }
    } catch (error) {
        console.error("Error fetching video resource:", error);
        return { code: 500, msg: "Error fetching video resource", data: [] };
    }

}

export async function getMedia(movieId: number): Promise<DataResponse<MovieMedia[]>> {

    try {
        const media = await prisma.filesInfo.findMany({
            where: { moviesId: movieId },
            select: {
                id: true,
                path: true,
                type: true,
                onlineUrl: true
            }
        });
        const playable = async (url: string) => {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 1000);

                const resp = await fetch(url, {
                    method: "HEAD",
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                const size = resp.headers.get("content-length");
                return size && parseInt(size) > 1024 * 10;
            } catch (error) {
                console.error("Error checking playability:", error);
                return false;
            }
        }

        const handledMedia = await Promise.all(media.map(async (x) => {
            const updatedMedia: MovieMedia = {
                id: x.id,
                path: `${process.env.MINIO_PATH}/${x.path}`,
                type: x.type || 0
            };

            if (x.type === 3) {
                const isPlayable = await playable(updatedMedia.path);
                if (!isPlayable) {
                    updatedMedia.useOnline = true;
                    updatedMedia.path = x.onlineUrl || updatedMedia.path;
                }
            }

            return updatedMedia;
        }));

        return {
            code: 200,
            data: handledMedia
        }
    } catch (error) {
        console.error("Error fetching media:", error);
        return { code: 500, msg: "Error fetching media", data: [] };
    }
}

export async function getMagnetLinks(movieId: number): Promise<DataResponse<MagnetLink[]>> {

    try {
        const magnetLinks = await prisma.magnetLinks.findMany({
            where: { moviesId: movieId },
            select: {
                id: true,
                linkUrl: true,
                size: true,
                uploadTime: true
            }
        });
        return {
            code: 200,
            data: magnetLinks
        }
    } catch (error) {
        console.error("Error fetching magnet links:", error);
        return { code: 500, msg: "Error fetching magnet links", data: [] };
    }

}

export async function getActressRelMovies(movieId: number): Promise<DataResponse<Movie[]>> {

    try {
        const movie = await prisma.moviesInfo.findUnique({
            where: { id: movieId },
            select: {
                actresses: true
            }
        });

        if (!movie) {
            return { code: 500, data: [] };
        }

        if (movie.actresses.length === 0 || movie.actresses.length > 2) {
            return { code: 200, data: [] };
        }

        const actressNames = movie.actresses.map((x: any) => x.actressName);

        const relMovies = await prisma.moviesInfo.findMany({
            where: { actresses: { some: { actressName: { in: actressNames } } } },
            select: movieSelect,
            take: 6
        });
        const filteredRelMovies = relMovies.filter((x: any) => x.id !== movieId);


        // If we removed a movie, fetch one more to maintain 6 movies
        if (filteredRelMovies.length < relMovies.length) {
            const additionalMovie = await prisma.moviesInfo.findFirst({
                where: {
                    actresses: { some: { actressName: { in: actressNames } } },
                    NOT: { id: movieId },
                    id: { notIn: filteredRelMovies.map((m: any) => m.id) }
                },
                select: movieSelect
            });

            if (additionalMovie) {
                filteredRelMovies.push(additionalMovie);
            }
        }
        const { ctCode, dmCode } = await getCollectionAndDownloadCode();

        const handled = handleMovie(filteredRelMovies, {
            ctCode,
            dmCode,
        });



        return {
            code: 200,
            data: handled as Movie[] || []
        }

    } catch (error) {
        console.error("Error fetching actress rel movies:", error);
        return { code: 500, msg: "Error fetching actress rel movies", data: [] };
    }

}

export async function getCollectionMovies({
    page = 1,
    download,
    isStack = false
}: {
    page?: number;
    download?: string;
    isStack?: boolean;
}): Promise<DataResponse<Movie[] | ActressGroupedMovies[]>> {
    try {
        const { ctCode, dmCode } = await getCollectionAndDownloadCode();
        const cookieStore = cookies();
        const config: GlobalSettingsConfig = JSON.parse(cookieStore.get('config')?.value || '{}');


        if (isStack) {
            return await groupedMoviesByActress(page, 50);
        }


        const skip = (page - 1) * 50;
        let q = {
            include: {
                MovieInfo: {
                    include: {
                        files: { where: { type: 2 } },
                        actresses: {
                            select: {
                                id: true,
                                actressName: true
                            }
                        },
                    },
                },
            },
            orderBy: { createdTime: 'desc' as const },
            where: {
                movieCode: {
                    ...(download === "true" && { in: dmCode }),
                    ...(download === "false" && { notIn: dmCode })
                }
            },
            skip: skip,
            take: 50,
        };


        let [collectedMovies, totalCount] = await Promise.all([
            prisma.moviesCollection.findMany(q),
            prisma.moviesCollection.count({ where: q.where }),
        ]);

        const movies = collectedMovies.filter((x: any) => x.MovieInfo)
        const flatMovies = movies.map(x => ({
            collectedTime: x.createdTime,
            ...x.MovieInfo,
            rate: Number(x.MovieInfo?.rate ?? 0)
        }))

        let handledMovies: Movie[] | ActressGroupedMovies[] = [];


        handledMovies = handleMovie(flatMovies, {
            ctCode,
            dmCode,
        }, config) as Movie[];



        return {
            data: handledMovies,
            pagination: getPaginationData(totalCount, page, 50),
            code: 200,
        }

    } catch (error) {
        console.error("Error fetching collection movies:", error);
        return { code: 500, msg: "Error fetching collection movies", data: [] };
    }

}

export async function toggleCollection(code: string, refreshPath: string): Promise<DataResponse<boolean>> {
    try {
        const existingCollection = await prisma.moviesCollection.findUnique({
            where: {
                movieCode: code,
            },
        });

        if (existingCollection) {
            await prisma.moviesCollection.delete({
                where: {
                    movieCode: code,
                },
            });
            revalidatePath(refreshPath);
            return { code: 200, data: true, msg: "取消收藏成功" };
        }

        await prisma.moviesCollection.create({
            data: {
                movieCode: code,
            },
        });
        revalidatePath(refreshPath);
        return { code: 200, data: true, msg: "收藏成功" };
    } catch (error) {
        console.error("Error collecting movie:", error);
        return { code: 500, msg: "操作失败，请重试" };
    }
}

export async function getDownloadMovies(page = 1, collected: string) {
    try {
        const skip = (page - 1) * 50;

        const { ctCode, dmCode } = await getCollectionAndDownloadCode();

        let q = {
            where: {
                movieCode: {
                    ...(collected === 'true' && { in: ctCode }),
                    ...(collected === 'false' && { notIn: ctCode }),
                },
            },
            include: {
                MovieInfo: {
                    include: {
                        files: {
                            where: {
                                type: 2,
                            },
                        },
                        tags: {
                            select: {
                                id: true,
                                tagName: true
                            }
                        }
                    },
                },
            },
            orderBy: { createdTime: 'desc' },
            skip,
            distinct: ['movieCode'],
            take: 50,
        };

        let [result, totalCount] = await Promise.all([
            prisma.moviesVideoResource.findMany(q as any),
            prisma.moviesVideoResource.count({ where: q.where }),
        ]);

        const downloadMovies = result.map((x: any) => {
            const m = x.MovieInfo;
            const downloadTime = x.createdTime;
            delete x.createdTime;
            delete x.MovieInfo;
            return {
                downloadTime,
                ...x,
                ...m,
                rate: Number(m?.rate ?? 0)
            };
        });




        const pagination = getPaginationData(totalCount, page, 50);
        const handled = handleMovie(downloadMovies, {
            ctCode,
            dmCode,
        });



        return {
            data: handled as Movie[],
            pagination,
            code: 200,
        };
    } catch (error) {
        console.error("Error fetching download movies:", error);
        return {
            code: 500,
            msg: "Error fetching download movies",
            data: [],
        };
    }
}

/**
 * Fetches and groups movies by actress, with pagination support.
 *
 */
async function groupedMoviesByActress(page: number = 1, pageSize: number = 30): Promise<DataResponse<ActressGroupedMovies[]>> {
    const skip = (page - 1) * pageSize;

    const allMoviesWithActress = await prisma.moviesCollection.findMany({
        include: {
            MovieInfo: {
                include: {
                    actresses: {
                        select: {
                            id: true,
                            actressName: true,
                        }
                    }, // 关联演员信息
                    files: {
                        where: {
                            type: 2
                        },
                        select: {
                            path: true,
                            onlineUrl: true
                        }
                    },
                },
            },
        },
        orderBy: {
            createdTime: 'desc', // 按收藏时间倒序
        },
    });

    const cookieStore = cookies();
    const config: GlobalSettingsConfig = JSON.parse(cookieStore.get('config')?.value || '{}');
    const { ctCode, dmCode } = await getCollectionAndDownloadCode();

    const movies = allMoviesWithActress.filter((x: any) => x.MovieInfo)
    const flatMovies = movies.map(x => ({
        collectedTime: x.createdTime,
        ...x.MovieInfo,
        rate: Number(x.MovieInfo?.rate ?? 0)
    }))

    const handledMovies = handleMovie(flatMovies, {
        ctCode,
        dmCode,
    }, config) as Movie[];

    // Step 2: 分组电影，过滤掉演员电影数量超过2部的
    const groupedByActress = new Map<number, {
        actress: {
            id: number;
            actressName: string;
        };
        movies: Movie[];
        latestCollectedDate: Date;
    }>();

    // 遍历 handledMovies 中的每个电影收藏
    for (const movieCollection of handledMovies) {
        // 获取与电影收藏相关的女演员，如果没有则为空数组
        const actresses = movieCollection.actresses || [];
        // 遍历电影收藏中的每个女演员
        for (const actress of actresses) {
            // 如果 groupedByActress map 中还没有该女演员，则添加她
            if (!groupedByActress.has(actress.id)) {
                groupedByActress.set(actress.id, {
                    actress: {
                        id: actress.id,
                        actressName: actress.actressName!,
                    },
                    movies: [],
                    latestCollectedDate: movieCollection.collectedTime!, // 初始化为该电影收藏时间
                });
            }
            // 获取该女演员的分组
            const group = groupedByActress.get(actress.id)!;
            // 将电影收藏添加到女演员的分组中
            group.movies.push(movieCollection);
            // 更新该分组的最新收藏时间
            group.latestCollectedDate = new Date(Math.max(
                new Date(group.latestCollectedDate).getTime(),
                new Date(movieCollection.collectedTime!).getTime()
            ));
        }
    }

    // Step 3: 处理超过2部电影的演员
    const finalGroups: ActressGroupedMovies[] = [];
    for (const [_, group] of groupedByActress) {
        // if (group.movies.length > 2) {
        //     // 将超过2部电影的直接作为单独的返回项，限制返回3部
        //     group.movies = group.movies.slice(0, 3);
        // }
        finalGroups.push({
            actress: group.actress,
            movies: group.movies,
            size: group.movies.length,
            latestCollectedDate: group.latestCollectedDate,
        });
    }

    console.log('finalGroups[10]_xxx', finalGroups.slice(0, 10));

    // Step 4: 按组内最近收藏时间倒序排列
    finalGroups.sort((a, b) => b.latestCollectedDate.getTime() - a.latestCollectedDate.getTime());

    // Step 5: 分页处理
    const data = finalGroups.slice(skip, skip + pageSize);

    return { data, pagination: getPaginationData(finalGroups.length, page, pageSize), code: 200 };
}

export async function getCollectedMoviesByActressId(
    actressId: number,
    page: number = 1,
    pageSize: number = DEFAULT_PAGE_SIZE
): Promise<DataResponse<Movie[]>> {
    try {
        const skip = (page - 1) * pageSize;
        const cookieStore = cookies();
        const config: GlobalSettingsConfig = JSON.parse(cookieStore.get('config')?.value || '{}');

        let moviesQuery = {
            skip,
            take: pageSize,
            orderBy: { createdTime: "desc" as const },
            where: {
                MovieInfo: {
                    actresses: {
                        some: {
                            id: actressId
                        }
                    }
                }
            },
            include: {
                MovieInfo: {
                    include: {
                        files: { where: { type: 2 } },
                        actresses: {
                            select: {
                                id: true,
                                actressName: true
                            }
                        },
                        tags: {
                            select: {
                                id: true,
                                tagName: true
                            }
                        }
                    }
                }
            }
        };

        const [collectedMovies, totalCount] = await Promise.all([
            prisma.moviesCollection.findMany(moviesQuery),
            prisma.moviesCollection.count({ where: moviesQuery.where }),
        ]);

        const { ctCode, dmCode } = await getCollectionAndDownloadCode();

        const movies = collectedMovies
            .filter((x: any) => x.MovieInfo)
            .map(x => ({
                collectedTime: x.createdTime,
                ...x.MovieInfo,
                rate: Number(x.MovieInfo?.rate ?? 0)
            }));

        const handled = handleMovie(movies, {
            ctCode,
            dmCode,
        },
            config
        );

        const pagination = getPaginationData(totalCount, page, pageSize);

        return {
            data: handled as Movie[] || [],
            pagination,
            code: 200,
        };
    } catch (error) {
        console.error("Error fetching collected movies by actress ID:", error);
        return { code: 500, msg: "Error fetching collected movies by actress ID", data: [] };
    }
}
